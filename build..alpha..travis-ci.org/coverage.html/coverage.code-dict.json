{"/home/travis/build/npmtest/node-npmtest-broken-link-checker/test.js":"/* istanbul instrument in package npmtest_broken_link_checker */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-broken-link-checker/lib.npmtest_broken_link_checker.js":"/* istanbul instrument in package npmtest_broken_link_checker */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_broken_link_checker = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_broken_link_checker = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-broken-link-checker/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-broken-link-checker && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_broken_link_checker */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_broken_link_checker\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_broken_link_checker.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_broken_link_checker.rollup.js'] =\n            local.assetsDict['/assets.npmtest_broken_link_checker.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_broken_link_checker.__dirname + '/lib.npmtest_broken_link_checker.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-broken-link-checker/node_modules/broken-link-checker/lib/index.js":"\"use strict\";\nvar reasons = require(\"./internal/messages\").reasons;\n\n\n\nvar blc = \n{\n\tHtmlChecker:    require(\"./public/HtmlChecker\"),\n\tHtmlUrlChecker: require(\"./public/HtmlUrlChecker\"),\n\tSiteChecker:    require(\"./public/SiteChecker\"),\n\tUrlChecker:     require(\"./public/UrlChecker\")\n};\n\n\n\nfor (var i in reasons)\n{\n\tblc[i] = reasons[i];\n}\n\n\n\nmodule.exports = blc;\n","/home/travis/build/npmtest/node-npmtest-broken-link-checker/node_modules/broken-link-checker/lib/internal/messages.js":"\"use strict\";\nvar errno = require(\"errno\").code;\nvar statusCodes = require(\"http\").STATUS_CODES;\n\nvar i;\n\nvar errors = \n{\n\tEXPECTED_HTML: function(type)\n\t{\n\t\ttype = type==null ? type : '\"'+type+'\"';\n\t\treturn 'Expected type \"text/html\" but got '+type;\n\t},\n\tHTML_RETRIEVAL: \"HTML could not be retrieved\"\n};\n\nvar reasons =\n{\n\t//BLC_CUSTOM: \"Custom Exclusion\",\n\tBLC_EXTERNAL: \"External URL Exclusion\",\n\tBLC_INTERNAL: \"Internal URL Exclusion\",\n\tBLC_HTML: \"HTML Exclusion\",\n\tBLC_INVALID: \"Invalid URL\",\n\tBLC_KEYWORD: \"Keyword Exclusion\",\n\t//BLC_LOCALPATH: \"Local File Path Exclusion\",\n\tBLC_ROBOTS: \"Robots Exclusion\",\n\tBLC_SAMEPAGE: \"Same-page URL Exclusion\",\n\tBLC_SCHEME: \"Scheme Exclusion\",\n\tBLC_UNKNOWN: \"Unknown Error\",\n\t\n\tERRNO_ENOTFOUND: \"no matching dns record (ENOTFOUND)\"\n};\n\n\n\nfor (i in errno)\n{\n\treasons[\"ERRNO_\"+i] = errno[i].description +\" (\"+i+\")\";\n}\n\n\n\nfor (i in statusCodes)\n{\n\treasons[\"HTTP_\"+i] = statusCodes[i] +\" (\"+i+\")\";\n}\n\n\n\nmodule.exports = \n{\n\terrors: errors,\n\treasons: reasons\n};\n","/home/travis/build/npmtest/node-npmtest-broken-link-checker/node_modules/broken-link-checker/lib/public/HtmlChecker.js":"\"use strict\";\nvar linkObj      = require(\"../internal/linkObj\");\nvar matchUrl     = require(\"../internal/matchUrl\");\nvar parseHtml    = require(\"../internal/parseHtml\");\nvar parseOptions = require(\"../internal/parseOptions\");\nvar scrapeHtml   = require(\"../internal/scrapeHtml\");\n\nvar UrlChecker = require(\"./UrlChecker\");\n\nvar isString = require(\"is-string\");\nvar linkTypes = require(\"link-types\").map;\nvar maybeCallback = require(\"maybe-callback\");\nvar RobotDirectives = require(\"robot-directives\");\n\n\n\nfunction HtmlChecker(options, handlers)\n{\n\tvar thisObj = this;\n\t\n\treset(this);\n\t\n\tthis.handlers = handlers || {};\n\tthis.options = options = parseOptions(options);\n\t\n\tthis.urlChecker = new UrlChecker(this.options,\n\t{\n\t\tlink: function(result)\n\t\t{\n\t\t\tmaybeCallback(thisObj.handlers.link)(result);\n\t\t},\n\t\tend: function()\n\t\t{\n\t\t\t// If stream finished\n\t\t\tif (thisObj.parsed === true)\n\t\t\t{\n\t\t\t\tcomplete(thisObj);\n\t\t\t}\n\t\t}\n\t});\n}\n\n\n\nHtmlChecker.prototype.clearCache = function()\n{\n\treturn this.urlChecker.clearCache();\n};\n\n\n\nHtmlChecker.prototype.numActiveLinks = function()\n{\n\treturn this.urlChecker.numActiveLinks();\n};\n\n\n\nHtmlChecker.prototype.numQueuedLinks = function()\n{\n\treturn this.urlChecker.numQueuedLinks();\n};\n\n\n\nHtmlChecker.prototype.pause = function()\n{\n\treturn this.urlChecker.pause();\n};\n\n\n\nHtmlChecker.prototype.resume = function()\n{\n\treturn this.urlChecker.resume();\n};\n\n\n\nHtmlChecker.prototype.scan = function(html, baseUrl, robots)\n{\n\tvar tree;\n\tvar thisObj = this;\n\t\n\tif (this.active === false)\n\t{\n\t\t// Prevent user error with undocumented arugment\n\t\tif (robots instanceof RobotDirectives === false)\n\t\t{\n\t\t\trobots = new RobotDirectives({ userAgent: this.options.userAgent });\n\t\t}\n\t\t\n\t\tthis.active = true;\n\t\tthis.baseUrl = baseUrl;\n\t\tthis.robots = robots;\n\t\t\n\t\tparseHtml(html).then( function(document)\n\t\t{\n\t\t\ttree = document;\n\t\t\treturn scrapeHtml(document, thisObj.robots);\n\t\t})\n\t\t.then( function(links)\n\t\t{\n\t\t\tmaybeCallback(thisObj.handlers.html)(tree, thisObj.robots);\n\t\t\t\n\t\t\tfor (var i=0, numLinks=links.length; i<numLinks; i++)\n\t\t\t{\n\t\t\t\tenqueueLink(links[i], thisObj);\n\t\t\t}\n\t\t\t\n\t\t\tthisObj.parsed = true;\n\t\t\t\n\t\t\t// If no links found or all links already checked\n\t\t\tif (thisObj.urlChecker.numActiveLinks()===0 && thisObj.urlChecker.numQueuedLinks()===0)\n\t\t\t{\n\t\t\t\tcomplete(thisObj);\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn true;\n\t}\n\t\n\treturn false;\n};\n\n\n\nHtmlChecker.prototype.__getCache = function()\n{\n\treturn this.urlChecker.__getCache();\n};\n\n\n\n//::: PRIVATE FUNCTIONS\n\n\n\nfunction complete(instance)\n{\n\treset(instance);\n\t\n\tmaybeCallback(instance.handlers.complete)();\n}\n\n\n\nfunction enqueueLink(link, instance)\n{\n\tvar excludedReason;\n\t\n\tlinkObj.resolve(link, instance.baseUrl, instance.options);\n\t\n\texcludedReason = excludeLink(link, instance);\n\t\n\tif (excludedReason !== false)\n\t{\n\t\tlink.html.offsetIndex = instance.excludedLinks++;\n\t\tlink.excluded = true;\n\t\tlink.excludedReason = excludedReason;\n\t\t\n\t\tlinkObj.clean(link);\n\t\t\n\t\tmaybeCallback(instance.handlers.junk)(link);\n\t\t\n\t\treturn;\n\t}\n\t\n\tlink.html.offsetIndex = link.html.index - instance.excludedLinks;\n\tlink.excluded = false;\n\t\n\tinstance.linkEnqueued = instance.urlChecker.enqueue(link);\n\t\n\t// TODO :: is this redundant? maybe use `linkObj.invalidate()` in `excludeLink()` ?\n\tif (instance.linkEnqueued instanceof Error)\n\t{\n\t\tlink.broken = true;\n\t\t// TODO :: update limited-request-queue to support path-only URLs\n\t\tlink.brokenReason = instance.linkEnqueued.message===\"Invalid URI\" ? \"BLC_INVALID\" : \"BLC_UNKNOWN\";\n\t\t\n\t\tlinkObj.clean(link);\n\t\t\n\t\tmaybeCallback(instance.handlers.link)(link);\n\t}\n}\n\n\n\nfunction excludeLink(link, instance)\n{\n\tvar attrSupported,externalFilter;\n\tvar attrName = link.html.attrName;\n\tvar tagName = link.html.tagName;\n\tvar tagGroup = instance.options.tags[instance.options.filterLevel][tagName];\n\t\n\tif (tagGroup != null)\n\t{\n\t\tattrSupported = tagGroup[attrName];\n\t}\n\t\n\tif (attrSupported !== true) return \"BLC_HTML\";\n\tif (instance.options.excludeExternalLinks===true   && link.internal===false) return \"BLC_EXTERNAL\";\n\tif (instance.options.excludeInternalLinks===true   && link.internal===true)  return \"BLC_INTERNAL\";\n\tif (instance.options.excludeLinksToSamePage===true && link.samePage===true)  return \"BLC_SAMEPAGE\";\n\tif (instance.options.excludedSchemes[link.url.parsed.extra.protocolTruncated] === true) return \"BLC_SCHEME\";\n\t\n\tif (instance.options.honorRobotExclusions === true)\n\t{\n\t\tif (instance.robots.oneIs([ RobotDirectives.NOFOLLOW, RobotDirectives.NOINDEX ]) === true)\n\t\t{\n\t\t\treturn \"BLC_ROBOTS\";\n\t\t}\n\t\t\n\t\tif (instance.robots.is(RobotDirectives.NOIMAGEINDEX) === true)\n\t\t{\n\t\t\tif (\n\t\t\t    (tagName===\"img\"      && attrName===\"src\"   ) || \n\t\t\t    (tagName===\"input\"    && attrName===\"src\"   ) || \n\t\t\t    (tagName===\"menuitem\" && attrName===\"icon\"  ) || \n\t\t\t    (tagName===\"video\"    && attrName===\"poster\")\n\t\t\t   )\n\t\t\t{\n\t\t\t\treturn \"BLC_ROBOTS\";\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (link.html.attrs!=null && link.html.attrs.rel!=null && linkTypes(link.html.attrs.rel).nofollow===true)\n\t\t{\n\t\t\treturn \"BLC_ROBOTS\";\n\t\t}\n\t}\n\t\n\tif (matchUrl(link.url.resolved, instance.options.excludedKeywords) === true) return \"BLC_KEYWORD\";\n\t\n\t// Undocumented handler for custom constraints\n\texternalFilter = maybeCallback(instance.handlers._filter)(link);\n\t\n\tif (isString(externalFilter) === true)\n\t{\n\t\treturn externalFilter;\n\t}\n\t/*else if (externalFilter === false)\n\t{\n\t\treturn \"BLC_CUSTOM\";\n\t}*/\n\t\n\treturn false;\n}\n\n\n\nfunction reset(instance)\n{\n\tinstance.active = false;\n\tinstance.baseUrl = undefined;\n\tinstance.excludedLinks = 0;\n\tinstance.linkEnqueued = null;\n\tinstance.parsed = false;\n\tinstance.robots = null;\n}\n\n\n\nmodule.exports = HtmlChecker;\n","/home/travis/build/npmtest/node-npmtest-broken-link-checker/node_modules/broken-link-checker/lib/internal/linkObj.js":"\"use strict\";\nvar isString = require(\"is-string\");\nvar urllib = require(\"url\");\nvar urlobj = require(\"urlobj\");\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\nfunction linkObj(url)\n{\n\tif (url===undefined || isString(url)===false)\n\t{\n\t\turl = null;\n\t}\n\t\n\tvar link = \n\t{\n\t\turl:\n\t\t{\n\t\t\toriginal: url,      // The URL as it was inputted\n\t\t\tresolved: null,     // The URL, resolved as a browser would do so\n\t\t\tredirected: null    // The URL, after its last redirection, if any\n\t\t},\n\t\t\n\t\tbase:\n\t\t{\n\t\t\toriginal: null,     // The base URL as it was inputted\n\t\t\tresolved: null      // The base URL, resolved as a browser would do so\n\t\t},\n\t\t\n\t\thtml:\n\t\t{\n\t\t\tindex: null,        // The order in which the link appeared in its document -- using max-level tag filter\n\t\t\toffsetIndex: null,  // Sequential (gap-free) indicies for skipped and unskipped links\n\t\t\tlocation:null,      // Source code location of the attribute that the link was found within\n\t\t\tselector: null,     // CSS selector for element in document\n\t\t\ttagName: null,      // Tag name that the link was found on\n\t\t\tattrName: null,     // Attribute name that the link was found within\n\t\t\tattrs: null,        // All attributes on the element\n\t\t\ttext: null,         // TextNode/innerText within the element\n\t\t\ttag: null,          // The entire tag string\n\t\t\t\n\t\t\t// Temporary keys\n\t\t\tbase: null\n\t\t},\n\t\t\n\t\thttp:\n\t\t{\n\t\t\tcached: null,       // If the response was pulled from cache\n\t\t\tresponse: null      // The request response\n\t\t},\n\t\t\n\t\tbroken: null,           // If the link was determined to be broken or not\n\t\tinternal: null,         // If the link is to the same server as its base/document\n\t\tsamePage: null,         // If the link is to the same page as its base/document\n\t\texcluded: null,         // If the link was excluded due to any filtering\n\t\t\n\t\tbrokenReason: null,     // The reason why the link was considered broken, if it indeed is\n\t\texcludedReason: null,   // The reason why the link was excluded from being checked, if it indeed was\n\t\t\n\t\t// Temporary keys\n\t\tbroken_link_checker: true,\n\t\tresolved: false\n\t};\n\t\n\t// Not enumerable -- hidden from `JSON.stringify()`\n\tObject.defineProperty(link.base, \"parsed\", { value:null, writable:true });  // Same as `link.base.resolved`, but is an Object\n\tObject.defineProperty(link.url,  \"parsed\", { value:null, writable:true });  // Same as `link.url.resolved`, but is an Object\n\t\n\treturn link;\n}\n\n\n\n/*\n\tRemove unnecessary keys for public use.\n*/\nlinkObj.clean = function(link)\n{\n\tdelete link.broken_link_checker;\n\tdelete link.html.base;  // TODO :: don't clean this?\n\tdelete link.resolved;\n\t\n\treturn link;\n};\n\n\n\n/*\n\tDefine relationships with base URL.\n*/\nlinkObj.relation = function(link, url_parsed)\n{\n\tif (url_parsed === undefined) url_parsed = link.url.parsed;\n\telse if (typeof url_parsed === \"string\") url_parsed = urlobj.parse(url_parsed);\n\t\n\tvar relation;\n\t\n\t// If no protocols, it's impossible to determine if they link to the same server\n\tif (url_parsed.protocol===null || link.base.parsed.protocol===null)\n\t{\n\t\t// Overwrite any previous values\n\t\tlink.internal = null;\n\t\tlink.samePage = null;\n\t}\n\telse\n\t{\n\t\t// Resolved base not used because html base could be remote\n\t\trelation = urlobj.relation(url_parsed, link.base.parsed);\n\t\t\n\t\tlink.internal = relation >= urlobj.component.AUTH;\n\t\tlink.samePage = link.internal===true && relation>=urlobj.component.PATH;\n\t}\n\t\n\treturn link;\n};\n\n\n\n/*\n\tAbsolute'ize a link based on its base URL and HTML's <base>.\n*/\n// TODO :: make similar to `url.resolve(from,to)` ?\nlinkObj.resolve = function(link, base, options)\n{\n\t// If already resolved\n\tif (link.resolved === true) return;\n\t\n\t// Parity with core `url.resolve()`\n\tvar parseOptions = { slashesDenoteHost:true };\n\t\n\t\n\t\n\t// TODO :: we're constantly re-parsing base and html base -- find way to cache them\n\tvar base_parsed = base==null ? \"\" : base;\n\tbase_parsed = urlobj.normalize( urlobj.parse(base_parsed, parseOptions) );\n\t\n\tvar htmlBase_parsed = link.html.base==null ? \"\" : link.html.base;\n\thtmlBase_parsed = urlobj.normalize( urlobj.parse(htmlBase_parsed, parseOptions) );\n\t\n\t// TODO :: options.normalize=false\n\t// TODO :: options.clone=true ?\n\tvar resolvedBase_parsed = urlobj.resolve(base_parsed, htmlBase_parsed);\n\t\n\tif (resolvedBase_parsed.hash !== null)\n\t{\n\t\t// Hashes are useless in a base\n\t\tresolvedBase_parsed.hash = null;\n\t\tresolvedBase_parsed.href = urllib.format(resolvedBase_parsed);  // TODO :: use urlobj.format() when available\n\t}\n\t\n\t// TODO :: is this necessary if `link.base.parsed` is cleaned?\n\tif (base_parsed.hash !== null)\n\t{\n\t\t// Hashes are useless in a base\n\t\tbase_parsed.hash = null;\n\t\tbase_parsed.href = urllib.format(base_parsed);  // TODO :: use urlobj.format() when available\n\t}\n\t\n\t\n\t\n\t// `link.url.original` should only ever not have a value within internal tests\n\tvar linkOrg_parsed = link.url.original==null ? \"\" : link.url.original;\n\tlinkOrg_parsed = urlobj.parse(linkOrg_parsed, parseOptions);\n\turlobj.normalize(linkOrg_parsed);\n\t\n\t// `linkOrg_parsed` is cloned to avoid it being mutated\n\t// TODO :: options.clone=true\n\tvar resolvedUrl_parsed = urlobj.resolve( resolvedBase_parsed, cloneObject(linkOrg_parsed) );\n\t\n\t\n\t\n\tif (base !== undefined)\n\t{\n\t\tlink.base.original = base;\n\t}\n\t\n\t// TODO :: use url types (>UNKNOWN && !=EMPTY ... not simple enough)\n\tif (resolvedBase_parsed.href !== \"\")\n\t{\n\t\tlink.base.resolved = parity(resolvedBase_parsed.href);\n\t}\n\t\n\tlink.base.parsed = base_parsed;\n\t\n\t// If resolved link has accepted scheme\n\tif (options.acceptedSchemes[ resolvedUrl_parsed.extra.protocolTruncated ] === true)\n\t{\n\t\tlink.url.resolved = parity(resolvedUrl_parsed.href);\n\t\tlink.url.parsed   = resolvedUrl_parsed;\n\t\t\n\t\t// TODO :: move relation stuff out of this function -- separation of concerns?\n\t\tlinkObj.relation(link);\n\t}\n\t// Else could not be properly resolved\n\telse\n\t{\n\t\tlink.url.parsed = linkOrg_parsed;\n\t\t\n\t\t// If at least resolved to absolute\n\t\tif (resolvedUrl_parsed.extra.type === urlobj.type.ABSOLUTE)\n\t\t{\n\t\t\t// If base is accepted scheme\n\t\t\tif (options.acceptedSchemes[ base_parsed.extra.protocolTruncated ] === true)\n\t\t\t{\n\t\t\t\tlink.internal = false;\n\t\t\t\tlink.samePage = false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t\n\t// Avoid future resolving\n\tlink.resolved = true;\n\t\n\treturn link;\n};\n\n\n\n//::: PRIVATE FUNCTIONS\n\n\n\n/*\n\tClones an object and its prototype while maintaining enumerable\n\tkeys and support for `instanceof`.\n*/\n// TODO :: this may not be necessary if linkObj.base.parsed and linkObj.url.parsed are cleaned out\n// TODO :: move this into urlobj\nfunction cloneObject(source)\n{\n\tvar clone,key,value;\n\t\n\tif (Array.isArray(source) === true)\n\t{\n\t\tclone = [];\n\t}\n\telse\n\t{\n\t\t// Only clone the prototype -- more efficient as it will not convert keys to prototype keys\n\t\tclone = Object.create( Object.getPrototypeOf(source) );\n\t}\n\t\n\t// Clone keys/indexes\n\t// TODO :: use Object.keys() for more speed\n\tfor (key in source)\n\t{\n\t\tif (hasOwnProperty.call(source, key) === true)\n\t\t{\n\t\t\tvalue = source[key];\n\t\t\t\n\t\t\tif (value!==null && typeof value===\"object\")\n\t\t\t{\n\t\t\t\tclone[key] = cloneObject(value);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tclone[key] = value;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn clone;\n}\n\n\n\n/*\n\tMaintain parity with core `url.resolve()`.\n*/\n// TODO :: remove this?\nfunction parity(url)\n{\n\treturn (url !== \"http://\") ? url : \"http:///\";\n}\n\n\n\nmodule.exports = linkObj;\n","/home/travis/build/npmtest/node-npmtest-broken-link-checker/node_modules/broken-link-checker/lib/internal/matchUrl.js":"\"use strict\";\nvar calmcard = require(\"calmcard\");\n\n\n\nfunction matchUrl(url, keywords)\n{\n\tvar i,numKeywords;\n\t\n\tif (url != null)\n\t{\n\t\tnumKeywords = keywords.length;\n\t\t\n\t\tfor (i=0; i<numKeywords; i++)\n\t\t{\n\t\t\t// Check for literal keyword\n\t\t\tif (url.indexOf(keywords[i]) > -1)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// Check for glob'bed keyword\n\t\t\telse if ( calmcard(keywords[i], url) === true )\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\n\n\nmodule.exports = matchUrl;\n","/home/travis/build/npmtest/node-npmtest-broken-link-checker/node_modules/broken-link-checker/lib/internal/parseHtml.js":"\"use strict\";\nvar isStream = require(\"is-stream\");\nvar isString = require(\"is-string\");\nvar parse5 = require(\"parse5\");\n\nvar treeAdapter = Object.create( parse5.treeAdapters.default );\ntreeAdapter.createElement_old = treeAdapter.createElement;\ntreeAdapter.createElement = function(tagName, namespaceURI, attrs)\n{\n\tvar result = treeAdapter.createElement_old(tagName, namespaceURI, attrs);\n\t\n\tif (result.attrs != null)\n\t{\n\t\tresult.attrMap = getAttrMap(result.attrs);\n\t}\n\t\n    return result;\n};\n\nvar options = { locationInfo:true, treeAdapter:treeAdapter };\n\n\n\n/*\n\tConvert attributes array to a map.\n\t\n\tNote: parse5 will have already handled multiple attrs of the\n\tsame name.\n*/\nfunction getAttrMap(attrs)\n{\n\tvar i;\n\tvar map = {};\n\tvar numAttrs = attrs.length;\n\t\n\tfor (i=0; i<numAttrs; i++)\n\t{\n\t\tmap[ attrs[i].name ] = attrs[i].value;\n\t}\n\t\n\treturn map;\n}\n\n\n\n/*\n\tParse an HTML stream/string and return a tree.\n*/\nfunction parseHtml(input)\n{\n\treturn new Promise( function(resolve, reject)\n\t{\n\t\tif (isStream(input) === true)\n\t\t{\n\t\t\tvar parser = new parse5.ParserStream(options);\n\t\t\t\n\t\t\tparser.on(\"finish\", function()\n\t\t\t{\n\t\t\t\tresolve(parser.document);\n\t\t\t});\n\t\t\t\n\t\t\tinput.pipe(parser);\n\t\t}\n\t\telse if (isString(input) === true)\n\t\t{\n\t\t\tresolve( parse5.parse(input, options) );\n\t\t}\n\t\telse\n\t\t{\n\t\t\treject(\"Invalid input\");\n\t\t}\n\t});\n}\n\n\n\nmodule.exports = parseHtml;\n","/home/travis/build/npmtest/node-npmtest-broken-link-checker/node_modules/broken-link-checker/lib/internal/parseOptions.js":"\"use strict\";\nvar defaultOptions = require(\"./defaultOptions\");\n\n\n\n/*\n\tConvert an Array to a boolean-value Map.\n\t\n\t[\"asdf1\",\"asdf2\"]\n\t\n\tto\n\t\n\t{ asdf1:true, asdf2:true }\n*/\nfunction array2booleanMap(array)\n{\n\tvar i,map,numElements;\n\t\n\tif (Array.isArray(array) === true)\n\t{\n\t\tmap = {};\n\t\tnumElements = array.length;\n\t\t\n\t\tfor (i=0; i<numElements; i++)\n\t\t{\n\t\t\tmap[ array[i] ] = true;\n\t\t}\n\t\t\n\t\treturn map;\n\t}\n\t\n\t// Unknown input -- return\n\treturn array;\n}\n\n\n\nfunction parseOptions(options)\n{\n\tif (options==null || options.__parsed!==true)\n\t{\n\t\toptions = Object.assign({}, defaultOptions, options);\n\t\t\n\t\t// Maps have better search performance, but are not friendly for options\n\t\toptions.acceptedSchemes = array2booleanMap(options.acceptedSchemes);\n\t\toptions.excludedSchemes = array2booleanMap(options.excludedSchemes);\n\t\t\n\t\t// Undocumented -- avoids reparsing pass-thru options from class to class\n\t\toptions.__parsed = true;\n\t}\n\t\n\treturn options;\n}\n\n\n\nmodule.exports = parseOptions;\n","/home/travis/build/npmtest/node-npmtest-broken-link-checker/node_modules/broken-link-checker/lib/internal/defaultOptions.js":"\"use strict\";\nvar pkg = require(\"../../package.json\");\n\nvar userAgent = require(\"default-user-agent\");\n\nvar defaultOptions = \n{\n\tacceptedSchemes: [\"http\",\"https\"],\n\tcacheExpiryTime: 3600000,\n\tcacheResponses: true,\n\texcludedKeywords: [],\n\texcludedSchemes: [\"data\",\"geo\",\"javascript\",\"mailto\",\"sms\",\"tel\"],\n\texcludeExternalLinks: false,\n\texcludeInternalLinks: false,\n\texcludeLinksToSamePage: true,\n\tfilterLevel: 1,\n\thonorRobotExclusions: true,\n\tmaxSockets: Infinity,\n\tmaxSocketsPerHost: 1,\n\trateLimit: 0,\n\trequestMethod: \"head\",\n\tretry405Head: true,\n\ttags: require(\"./tags\"),\n\tuserAgent: userAgent(pkg.name, pkg.version)\n};\n\n\n\nmodule.exports = defaultOptions;\n","/home/travis/build/npmtest/node-npmtest-broken-link-checker/node_modules/broken-link-checker/lib/internal/tags.js":"\"use strict\";\n\nvar tags = \n{\n\t0:  // clickable links\n\t{\n\t\ta:      { href:true },\n\t\tarea:   { href:true }\n\t},\n\t1:  // clickable links, media, iframes, meta refreshes\n\t{\n\t\ta:        { href:true },\n\t\tarea:     { href:true },\n\t\taudio:    { src:true },\n\t\tembed:    { src:true },\n\t\tiframe:   { src:true },\n\t\timg:      { src:true },\n\t\tinput:    { src:true },\n\t\tmenuitem: { icon:true },\n\t\tmeta:     { content:true },\n\t\tobject:   { data:true },\n\t\tsource:   { src:true },\n\t\ttrack:    { src:true },\n\t\tvideo:    { poster:true, src:true }\n\t},\n\t2:  // clickable links, media, iframes, meta refreshes, stylesheets, scripts, forms\n\t{\n\t\ta:        { href:true },\n\t\tarea:     { href:true },\n\t\taudio:    { src:true },\n\t\tembed:    { src:true },\n\t\tform:     { action:true },\n\t\tiframe:   { src:true },\n\t\timg:      { src:true },\n\t\tinput:    { src:true },\n\t\tlink:     { href:true },\n\t\tmenuitem: { icon:true },\n\t\tmeta:     { content:true },\n\t\tobject:   { data:true },\n\t\tscript:   { src:true },\n\t\tsource:   { src:true },\n\t\ttrack:    { src:true },\n\t\tvideo:    { poster:true, src:true }\n\t},\n\t3:  // clickable links, media, iframes, meta refreshes, stylesheets, scripts, forms, metadata\n\t{\n\t\ta:          { href:true },\n\t\tarea:       { href:true },\n\t\taudio:      { src:true },\n\t\tblockquote: { cite:true },\n\t\tdel:        { cite:true },\n\t\tembed:      { src:true },\n\t\tform:       { action:true },\n\t\tiframe:     { longdesc:true, src:true },\n\t\timg:        { longdesc:true, src:true },\n\t\tinput:      { src:true },\n\t\tins:        { cite:true },\n\t\tlink:       { href:true },\n\t\tmenuitem:   { icon:true },\n\t\tmeta:       { content:true },\n\t\tobject:     { data:true },\n\t\tq:          { cite:true },\n\t\tscript:     { src:true },\n\t\tsource:     { src:true },\n\t\ttrack:      { src:true },\n\t\tvideo:      { poster:true, src:true }\n\t},\n\t\n\tlength: 4  // simulate Array\n};\n\n\n\n// Only used for `SiteChecker`\ntags.recursive = \n{\n\t0: tags[0],\n\t1:\n\t{\n\t\ta:        { href:true },\n\t\tarea:     { href:true },\n\t\tiframe:   { src:true },\n\t\tmeta:     { content:true },\n\t},\n\t2:\n\t{\n\t\ta:        { href:true },\n\t\tarea:     { href:true },\n\t\tiframe:   { src:true },\n\t\tmeta:     { content:true },\n\t},\n\t3:\n\t{\n\t\ta:          { href:true },\n\t\tarea:       { href:true },\n\t\tblockquote: { cite:true },\n\t\tdel:        { cite:true },\n\t\tiframe:     { longdesc:true, src:true },\n\t\timg:        { longdesc:true },\n\t\tins:        { cite:true },\n\t\tmeta:       { content:true },\n\t\tq:          { cite:true }\n\t}\n};\n\n\n\nmodule.exports = tags;\n","/home/travis/build/npmtest/node-npmtest-broken-link-checker/node_modules/broken-link-checker/lib/internal/scrapeHtml.js":"\"use strict\";\nvar linkObj = require(\"./linkObj\");\nvar tags    = require(\"./tags\");\n\nvar condenseWhitespace = require(\"condense-whitespace\");\nvar parseMetaRefresh = require(\"http-equiv-refresh\");\nvar RobotDirectives = require(\"robot-directives\");\n\nvar maxFilterLevel = tags[tags.length - 1];\n\n\n\n/*\n\tScrape a parsed HTML document/tree for links.\n*/\nfunction scrapeHtml(document, robots)\n{\n\tvar link,links,preliminaries,rootNode;\n\t\n\trootNode = findRootNode(document);\n\t\n\tif (rootNode != null)\n\t{\n\t\tpreliminaries = findPreliminaries(rootNode, robots);\n\t\tlinks = [];\n\t\t\n\t\tfindLinks(rootNode, function(node, attrName, url)\n\t\t{\n\t\t\tlink = linkObj(url);\n\t\t\tlink.html.attrs = node.attrMap;\n\t\t\tlink.html.attrName = attrName;\n\t\t\tlink.html.base = preliminaries.base;\n\t\t\tlink.html.index = links.length;\n\t\t\tlink.html.location = node.__location.attrs[attrName];\n\t\t\tlink.html.selector = getSelector(node);\n\t\t\tlink.html.tag = stringifyNode(node);\n\t\t\tlink.html.tagName = node.nodeName;\n\t\t\tlink.html.text = getText(node);\n\t\t\t\n\t\t\tlinks.push(link);\n\t\t});\n\t}\n\t\n\treturn links;\n}\n\n\n\n//::: PRIVATE FUNCTIONS\n\n\n\n/*\n\tTraverses the root node to locate links that match filters.\n*/\nfunction findLinks(rootNode, callback)\n{\n\tvar attrName,i,link,linkAttrs,numAttrs,url;\n\t\n\twalk(rootNode, function(node)\n\t{\n\t\tlinkAttrs = maxFilterLevel[node.nodeName];\n\t\t\n\t\t// If a supported element\n\t\tif (linkAttrs != null)\n\t\t{\n\t\t\tnumAttrs = node.attrs.length;\n\t\t\t\n\t\t\t// Faster to loop through Arrays than Objects\n\t\t\tfor (i=0; i<numAttrs; i++)\n\t\t\t{\n\t\t\t\tattrName = node.attrs[i].name;\n\t\t\t\turl = null;\n\t\t\t\t\n\t\t\t\t// If a supported attribute\n\t\t\t\tif (linkAttrs[attrName] === true)\n\t\t\t\t{\n\t\t\t\t\t// Special case for `<meta http-equiv=\"refresh\" content=\"5; url=redirect.html\">`\n\t\t\t\t\tif (node.nodeName===\"meta\" && attrName===\"content\")\n\t\t\t\t\t{\n\t\t\t\t\t\tif (node.attrMap[\"http-equiv\"]!=null && node.attrMap[\"http-equiv\"].toLowerCase()===\"refresh\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\turl = parseMetaRefresh( node.attrMap[attrName] ).url;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// https://html.spec.whatwg.org/multipage/infrastructure.html#valid-url-potentially-surrounded-by-spaces\n\t\t\t\t\t\turl = node.attrMap[attrName].trim();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (url != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tcallback(node, attrName, url);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n}\n\n\n\n/*\n\tTraverses the root node to locate preliminary elements/data.\n\t\n\t<base href/>\n\t\t\n\t\tLooks for the first instance. If no `href` attribute exists,\n\t\tthe element is ignored and possible successors are considered.\n\t\n\t<meta name content/>\n\t\t\n\t\tLooks for all robot instances and cascades the values.\n*/\nfunction findPreliminaries(rootNode, robots)\n{\n\tvar name;\n\tvar find = {\n\t\tbase: true,\n\t\trobots: robots != null\n\t};\n\tvar found = {\n\t\tbase: false\n\t};\n\tvar result = {\n\t\tbase: null\n\t};\n\t\n\twalk(rootNode, function(node)\n\t{\n\t\tswitch (node.nodeName)\n\t\t{\n\t\t\t// `<base>` can be anywhere, not just within `<head>`\n\t\t\tcase \"base\":\n\t\t\t{\n\t\t\t\tif (find.base===true && found.base===false && node.attrMap.href!=null)\n\t\t\t\t{\n\t\t\t\t\t// https://html.spec.whatwg.org/multipage/infrastructure.html#valid-url-potentially-surrounded-by-spaces\n\t\t\t\t\tresult.base = node.attrMap.href.trim();\n\t\t\t\t\t\n\t\t\t\t\tfound.base = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// `<meta>` can be anywhere\n\t\t\tcase \"meta\":\n\t\t\t{\n\t\t\t\tif (find.robots===true && node.attrMap.name!=null && node.attrMap.content!=null)\n\t\t\t\t{\n\t\t\t\t\tname = node.attrMap.name.trim().toLowerCase();\n\t\t\t\t\t\n\t\t\t\t\tswitch (name)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase \"description\":\n\t\t\t\t\t\tcase \"keywords\":\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Catches all because we have \"robots\" and countless botnames such as \"googlebot\"\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (name===\"robots\" || RobotDirectives.isBot(name)===true)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trobots.meta(name, node.attrMap.content);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (found.base===true && find.robots===false)\n\t\t{\n\t\t\t// Kill walk\n\t\t\treturn false;\n\t\t}\n\t});\n\t\n\treturn result;\n}\n\n\n\n/*\n\tFind the `<html>` element.\n*/\nfunction findRootNode(document)\n{\n\tvar i;\n\tvar rootNodes = document.childNodes;\n\t\n\tfor (i=0; i<rootNodes.length; i++)\n\t{\n\t\t// Doctypes have no `childNodes` property\n\t\tif (rootNodes[i].childNodes != null)\n\t\t{\n\t\t\treturn rootNodes[i];\n\t\t}\n\t}\n}\n\n\n\n/*\n\tFind a node's `:nth-child()` index among its siblings.\n*/\nfunction getNthIndex(node)\n{\n\tvar child,i;\n\tvar count = 0;\n\tvar parentsChildren = node.parentNode.childNodes;\n\tvar numParentsChildren = parentsChildren.length;\n\t\n\tfor (i=0; i<numParentsChildren; i++)\n\t{\n\t\tchild = parentsChildren[i];\n\t\t\n\t\tif (child !== node)\n\t\t{\n\t\t\t// Exclude text and comments nodes\n\t\t\tif (child.nodeName[0] !== \"#\")\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t// `:nth-child()` indices don't start at 0\n\treturn count+1;\n}\n\n\n\n/*\n\tBuilds a CSS selector that matches `node`.\n*/\nfunction getSelector(node)\n{\n\tvar name;\n\tvar selector = [];\n\t\n\twhile (node.nodeName !== \"#document\")\n\t{\n\t\tname = node.nodeName;\n\t\t\n\t\t// Only one of these are ever allowed -- so, index is unnecessary\n\t\tif (name!==\"html\" && name!==\"body\" & name!==\"head\")\n\t\t{\n\t\t\tname += \":nth-child(\"+ getNthIndex(node) +\")\";\n\t\t}\n\t\t\n\t\t// Building backwards\n\t\tselector.push(name);\n\t\t\n\t\tnode = node.parentNode;\n\t}\n\t\n\treturn selector.reverse().join(\" > \");\n}\n\n\n\nfunction getText(node)\n{\n\tvar text = null;\n\t\n\tif (node.childNodes.length > 0)\n\t{\n\t\ttext = \"\";\n\t\t\n\t\twalk(node, function(node)\n\t\t{\n\t\t\tif (node.nodeName === \"#text\")\n\t\t\t{\n\t\t\t\ttext += node.value;\n\t\t\t}\n\t\t});\n\t\t\n\t\t// TODO :: don't normalize if within <pre> ? use \"normalize-html-whitespace\" package if so\n\t\ttext = condenseWhitespace(text);\n\t}\n\t\n\treturn text;\n}\n\n\n\n/*\n\tSerialize an HTML node back to a string.\n*/\nfunction stringifyNode(node)\n{\n\tvar result = \"<\"+node.nodeName;\n\tvar numAttrs = node.attrs.length;\n\t\n\tfor (var i=0; i<numAttrs; i++)\n\t{\n\t\tresult += \" \"+ node.attrs[i].name +'=\"'+ node.attrs[i].value +'\"';\n\t}\n\t\n\tresult += \">\";\n\t\n\treturn result;\n}\n\n\n\n// TODO :: contribute these to npmjs.com/dom-walk\nfunction walk(node, callback)\n{\n\tvar childNode,i;\n\t\n\tif (callback(node) === false) return false;\n\t\n\tif (node.childNodes != null)\n\t{\n\t\ti = 0;\n\t\tchildNode = node.childNodes[i];\n\t}\n\t\n\twhile (childNode != null)\n\t{\n\t\tif (walk(childNode, callback) === false) return false;\n\t\t\n\t\tchildNode = node.childNodes[++i];\n\t}\n}\n// http://www.javascriptcookbook.com/article/Traversing-DOM-subtrees-with-a-recursive-walk-the-DOM-function/\n// Modified\n/*function walk(node, callback)\n{\n\tif (callback(node) === false) return false;\n\t\n\tnode = node.firstChild;\n\t\n\twhile (node != null)\n\t{\n\t\tif (walk(node, callback) === false) return false;\n\t\t\n\t\tnode = node.nextSibling;\n\t}\n}*/\n\n\n\nmodule.exports = scrapeHtml;\n","/home/travis/build/npmtest/node-npmtest-broken-link-checker/node_modules/broken-link-checker/lib/public/UrlChecker.js":"\"use strict\";\nvar checkUrl     = require(\"../internal/checkUrl\");\nvar linkObj      = require(\"../internal/linkObj\");\nvar parseOptions = require(\"../internal/parseOptions\");\n\nvar isString = require(\"is-string\");\nvar maybeCallback = require(\"maybe-callback\");\nvar RequestQueue = require(\"limited-request-queue\");\nvar UrlCache = require(\"urlcache\");\nvar urlobj = require(\"urlobj\");\n\n\n\nfunction UrlChecker(options, handlers)\n{\n\tvar thisObj = this;\n\t\n\tthis.handlers = handlers || {};\n\tthis.options = options = parseOptions(options);\n\n\tthis.cache = new UrlCache(\n\t{\n\t\texpiryTime: this.options.cacheExpiryTime,\n\t\tnormalizeUrls: false\n\t});\n\t\n\tthis.linkQueue = new RequestQueue(\n\t{\n\t\tmaxSockets:        this.options.maxSockets,\n\t\tmaxSocketsPerHost: this.options.maxSocketsPerHost,\n\t\trateLimit:         this.options.rateLimit\n\t},\n\t{\n\t\titem: function(input, done)\n\t\t{\n\t\t\t// TODO :: make this more reusable\n\t\t\tfunction handle_checkUrl(result)\n\t\t\t{\n\t\t\t\tmaybeCallback(thisObj.handlers.link)(result, input.data.customData);\n\t\t\t\t\n\t\t\t\t// Auto-starts next queue item, if any\n\t\t\t\t// If not, fires \"end\"\n\t\t\t\tdone();\n\t\t\t}\n\t\t\t\n\t\t\tif (input.data.linkObj !== undefined)\n\t\t\t{\n\t\t\t\tcheckUrl(input.data.linkObj, null, thisObj.cache, thisObj.options).then(handle_checkUrl);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO :: send url object -- remove orgUrl?\n\t\t\t\tcheckUrl(input.data.orgUrl, input.data.baseUrl, thisObj.cache, thisObj.options).then(handle_checkUrl);\n\t\t\t}\n\t\t},\n\t\tend: function()\n\t\t{\n\t\t\tmaybeCallback(thisObj.handlers.end)();\n\t\t}\n\t});\n}\n\n\n\nUrlChecker.prototype.clearCache = function()\n{\n\treturn this.cache.clear();\n};\n\n\n\nUrlChecker.prototype.dequeue = function(id)\n{\n\treturn this.linkQueue.dequeue(id);\n};\n\n\n\nUrlChecker.prototype.enqueue = function(url, baseUrl, customData)\n{\n\t// Undocumented internal use: enqueue(linkObj)\n\tif (isString(url)===false && url.broken_link_checker===true)\n\t{\n\t\treturn this.linkQueue.enqueue(\n\t\t{\n\t\t\turl: url.url.parsed,\n\t\t\tdata: { customData:customData, linkObj:url }\n\t\t});\n\t}\n\t// Documented use: enqueue(url, baseUrl)\n\t// or erroneous and let linkQueue sort it out\n\telse\n\t{\n\t\treturn this.linkQueue.enqueue(\n\t\t{\n\t\t\turl: urlobj.resolve(baseUrl || \"\", urlobj.parse(url) ),  // URL must be absolute\n\t\t\tdata: { orgUrl:url, baseUrl:baseUrl, customData:customData }\n\t\t});\n\t}\n};\n\n\n\nUrlChecker.prototype.numActiveLinks = function()\n{\n\treturn this.linkQueue.numActive();\n};\n\n\n\nUrlChecker.prototype.numQueuedLinks = function()\n{\n\treturn this.linkQueue.numQueued();\n};\n\n\n\nUrlChecker.prototype.pause = function()\n{\n\treturn this.linkQueue.pause();\n};\n\n\n\nUrlChecker.prototype.resume = function()\n{\n\treturn this.linkQueue.resume();\n};\n\n\n\nUrlChecker.prototype.__getCache = function()\n{\n\treturn this.cache;\n};\n\n\n\nmodule.exports = UrlChecker;\n","/home/travis/build/npmtest/node-npmtest-broken-link-checker/node_modules/broken-link-checker/lib/internal/checkUrl.js":"\"use strict\";\nvar linkObj        = require(\"./linkObj\");\nvar reasons        = require(\"./messages\").reasons;\nvar simpleResponse = require(\"./simpleResponse\");\n\nvar bhttp = require(\"bhttp\");\nvar extend = require(\"extend\");\nvar isString = require(\"is-string\");\n\n\n\n/*\n\tChecks a URL to see if it's broken or not.\n*/\nfunction checkUrl(link, baseUrl, cache, options, retry)\n{\n\tvar cached;\n\t\n\tif (retry === undefined)\n\t{\n\t\tif (isString(link) === true)\n\t\t{\n\t\t\tlink = linkObj(link);\n\t\t\tlinkObj.resolve(link, baseUrl, options);\n\t\t}\n\t\t\n\t\t// TODO :: move out to an `linkObj.invalidate()` to share with `HtmlChecker()` ?\n\t\tif (link.url.resolved === null)\n\t\t{\n\t\t\tlink.broken = true;\n\t\t\tlink.brokenReason = \"BLC_INVALID\";\n\t\t\tlinkObj.clean(link);\n\t\t\treturn Promise.resolve(link);\n\t\t}\n\t\t\n\t\tcached = cache.get(link.url.parsed);\n\t\t\n\t\tif (cached !== undefined)\n\t\t{\n\t\t\treturn Promise.resolve(cached).then( function(response)\n\t\t\t{\n\t\t\t\t// Cloned to avoid unexpected mutations as a result of user changes\n\t\t\t\tresponse = extend({}, response);\n\t\t\t\t\n\t\t\t\tcopyResponseData(response, link, options);\n\t\t\t\t\n\t\t\t\tlink.http.cached = true;\n\t\t\t\t\n\t\t\t\treturn link;\n\t\t\t});\n\t\t}\n\t}\n\t\n\tvar request = bhttp.request(link.url.resolved,  // TODO :: https://github.com/joepie91/node-bhttp/issues/3\n\t{\n\t\tdiscardResponse: true,\n\t\theaders: { \"user-agent\":options.userAgent },\n\t\tmethod: retry!==405 ? options.requestMethod : \"get\"\n\t})\n\t.then( function(response)\n\t{\n\t\tresponse = simpleResponse(response);\n\t\t\n\t\tif (response.statusCode===405 && options.requestMethod===\"head\" && options.retry405Head===true && retry!==405)\n\t\t{\n\t\t\t// Retry possibly broken server with \"get\"\n\t\t\treturn checkUrl(link, baseUrl, cache, options, 405);\n\t\t}\n\t\t\n\t\t// TODO :: store ALL redirected urls in cache\n\t\tif (options.cacheResponses===true && response.url!==link.url.resolved)\n\t\t{\n\t\t\tcache.set(response.url, response);  // TODO :: store `request` instead to be consistent?\n\t\t}\n\t\t\n\t\treturn response;\n\t})\n\t.catch( function(error)\n\t{\n\t\t// The error will be stored as a response\n\t\treturn error;\n\t});\n\t\n\tif (retry === undefined)\n\t{\n\t\t// Send response to cache -- it will be available to `cache.get()` before being resolved\n\t\tif (options.cacheResponses === true)\n\t\t{\n\t\t\tcache.set(link.url.parsed, request);\n\t\t}\n\t\t\n\t\t// Send linkObj to caller\n\t\treturn request.then( function(response)\n\t\t{\n\t\t\tcopyResponseData(response, link, options);\n\t\t\t\n\t\t\tlink.http.cached = false;\n\t\t\t\n\t\t\treturn link;\n\t\t});\n\t}\n\telse\n\t{\n\t\treturn request;\n\t}\n}\n\n\n\n/*\n\tCopy data from a bhttp response objecteither from a request or cache\n\tinto a link object.\n*/\nfunction copyResponseData(response, link, options)\n{\n\tif (response instanceof Error === false)\n\t{\n\t\tif (response.statusCode !== 200)\n\t\t{\n\t\t\tlink.broken = true;\n\t\t\tlink.brokenReason = \"HTTP_\" + response.statusCode;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlink.broken = false;\n\t\t}\n\t\t\n\t\tlink.http.response = response;\n\t\t\n\t\tif (link.url.resolved !== response.url)\n\t\t{\n\t\t\tlink.url.redirected = response.url;\n\t\t\t\n\t\t\tif (link.base.resolved !== null)\n\t\t\t{\n\t\t\t\t// TODO :: this needs a test\n\t\t\t\tlinkObj.relation(link, link.url.redirected);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tlink.broken = true;\n\t\t\n\t\tif (reasons[\"ERRNO_\"+response.code] != null)\n\t\t{\n\t\t\tlink.brokenReason = \"ERRNO_\" + response.code;\n\t\t}\n\t\t/*else if (response.message === \"Invalid URL\")\n\t\t{\n\t\t\tlink.brokenReason = \"BLC_INVALID\";\n\t\t}*/\n\t\telse\n\t\t{\n\t\t\tlink.brokenReason = \"BLC_UNKNOWN\";\n\t\t}\n\t}\n\t\n\tlinkObj.clean(link);\n}\n\n\n\nmodule.exports = checkUrl;\n","/home/travis/build/npmtest/node-npmtest-broken-link-checker/node_modules/broken-link-checker/lib/internal/simpleResponse.js":"\"use strict\";\n\n\n\nfunction simpleResponse(response)\n{\n\tvar simplified = simplify(response);\n\tsimplified.redirects = [];\n\t\n\tfor (var i=0; i<response.redirectHistory.length; i++)\n\t{\n\t\tsimplified.redirects.push( simplify(response.redirectHistory[i]) );\n\t}\n\t\n\treturn simplified;\n}\n\n\n\nfunction simplify(response)\n{\n\treturn {\n\t\theaders:       response.headers,\n\t\thttpVersion:   response.httpVersion,\n\t\tstatusCode:    response.statusCode,\n\t\tstatusMessage: response.statusMessage,\n\t\turl:           response.request.url\n\t};\n}\n\n\n\nmodule.exports = simpleResponse;\n","/home/travis/build/npmtest/node-npmtest-broken-link-checker/node_modules/broken-link-checker/lib/public/HtmlUrlChecker.js":"\"use strict\";\nvar parseOptions = require(\"../internal/parseOptions\");\nvar streamHtml   = require(\"../internal/streamHtml\");\n\nvar HtmlChecker = require(\"./HtmlChecker\");\n\nvar maybeCallback = require(\"maybe-callback\");\nvar RequestQueue = require(\"limited-request-queue\");\nvar RobotDirectives = require(\"robot-directives\");\n\n\n\nfunction HtmlUrlChecker(options, handlers)\n{\n\tvar thisObj = this;\n\t\n\treset(this);\n\t\n\tthis.handlers = handlers || {};\n\tthis.options = options = parseOptions(options);\n\t\n\tthis.htmlUrlQueue = new RequestQueue(\n\t{\n\t\tmaxSockets: 1,\n\t\trateLimit: this.options.rateLimit\n\t},\n\t{\n\t\titem: function(input, done)\n\t\t{\n\t\t\tthisObj.currentCustomData = input.data.customData;\n\t\t\tthisObj.currentDone = done;\n\t\t\tthisObj.currentPageUrl = input.url;\n\t\t\t\n\t\t\tstreamHtml(thisObj.currentPageUrl, thisObj.__getCache(), thisObj.options).then( function(result)\n\t\t\t{\n\t\t\t\tthisObj.currentResponse = result.response;\n\t\t\t\t\n\t\t\t\tthisObj.currentRobots = new RobotDirectives({ userAgent: thisObj.options.userAgent });\n\t\t\t\t\n\t\t\t\trobotHeaders(thisObj);\n\t\t\t\t\n\t\t\t\t// Passes robots instance so that headers are included in robot exclusion checks\n\t\t\t\tthisObj.htmlChecker.scan(result.stream, result.response.url, thisObj.currentRobots);\n\t\t\t})\n\t\t\t.catch( function(error)\n\t\t\t{\n\t\t\t\tcompletedPage(thisObj, error);\n\t\t\t});\n\t\t},\n\t\tend: function()\n\t\t{\n\t\t\t// Clear references for garbage collection\n\t\t\treset(thisObj);\n\t\t\t\n\t\t\tmaybeCallback(thisObj.handlers.end)();\n\t\t}\n\t});\n\t\n\tthis.htmlChecker = new HtmlChecker(this.options,\n\t{\n\t\thtml: function(tree, robots)\n\t\t{\n\t\t\tmaybeCallback(thisObj.handlers.html)(tree, robots, thisObj.currentResponse, thisObj.currentPageUrl, thisObj.currentCustomData);\n\t\t},\n\t\t_filter: function(result)\n\t\t{\n\t\t\t// Undocumented handler for excluding links via custom constraints\n\t\t\treturn maybeCallback(thisObj.handlers._filter)(result);\n\t\t},\n\t\tjunk: function(result)\n\t\t{\n\t\t\tmaybeCallback(thisObj.handlers.junk)(result, thisObj.currentCustomData);\n\t\t},\n\t\tlink: function(result)\n\t\t{\n\t\t\tmaybeCallback(thisObj.handlers.link)(result, thisObj.currentCustomData);\n\t\t},\n\t\tcomplete: function()\n\t\t{\n\t\t\tcompletedPage(thisObj, null);\n\t\t}\n\t});\n}\n\n\n\nHtmlUrlChecker.prototype.clearCache = function()\n{\n\treturn this.htmlChecker.clearCache();\n};\n\n\n\nHtmlUrlChecker.prototype.dequeue = function(id)\n{\n\treturn this.htmlUrlQueue.dequeue(id);\n};\n\n\n\nHtmlUrlChecker.prototype.enqueue = function(pageUrl, customData)\n{\n\treturn this.htmlUrlQueue.enqueue(\n\t{\n\t\turl: pageUrl,\n\t\tdata: { customData:customData }\n\t});\n};\n\n\n\nHtmlUrlChecker.prototype.numActiveLinks = function()\n{\n\treturn this.htmlChecker.numActiveLinks();\n};\n\n\n\nHtmlUrlChecker.prototype.numPages = function()\n{\n\treturn this.htmlUrlQueue.length();\n};\n\n\n\nHtmlUrlChecker.prototype.numQueuedLinks = function()\n{\n\treturn this.htmlChecker.numQueuedLinks();\n};\n\n\n\nHtmlUrlChecker.prototype.pause = function()\n{\n\tthis.htmlChecker.pause();\n\treturn this.htmlUrlQueue.pause();\n};\n\n\n\nHtmlUrlChecker.prototype.resume = function()\n{\n\tthis.htmlChecker.resume();\n\treturn this.htmlUrlQueue.resume();\n};\n\n\n\nHtmlUrlChecker.prototype.__getCache = function()\n{\n\treturn this.htmlChecker.__getCache();\n};\n\n\n\n//::: PRIVATE FUNCTIONS\n\n\n\nfunction completedPage(instance, error)\n{\n\tmaybeCallback(instance.handlers.page)(error, instance.currentPageUrl, instance.currentCustomData);\n\t\n\t// Auto-starts next queue item, if any\n\t// If not, fires \"end\"\n\tinstance.currentDone();\n}\n\n\n\nfunction reset(instance)\n{\n\tinstance.currentCustomData = null;\n\tinstance.currentDone = null;\n\tinstance.currentPageUrl = null;\n\tinstance.currentResponse = null;\n\tinstance.currentRobots = null;\n}\n\n\n\nfunction robotHeaders(instance)\n{\n\t// TODO :: https://github.com/joepie91/node-bhttp/issues/20\n\t// TODO :: https://github.com/nodejs/node/issues/3591\n\tif (instance.currentResponse.headers[\"x-robots-tag\"] != null)\n\t{\n\t\tinstance.currentRobots.header( instance.currentResponse.headers[\"x-robots-tag\"] );\n\t}\n}\n\n\n\nmodule.exports = HtmlUrlChecker;\n","/home/travis/build/npmtest/node-npmtest-broken-link-checker/node_modules/broken-link-checker/lib/internal/streamHtml.js":"\"use strict\";\nvar errors         = require(\"./messages\").errors;\nvar simpleResponse = require(\"./simpleResponse\");\n\nvar bhttp = require(\"bhttp\");\n\n\n\nfunction checkErrors(response)\n{\n\tvar error,type;\n\t\n\tif (response.statusCode !== 200)\n\t{\n\t\terror = new Error(errors.HTML_RETRIEVAL);\n\t\terror.code = response.statusCode;\n\t\treturn error;\n\t}\n\t\n\ttype = response.headers[\"content-type\"];\n\t\n\t// content-type is not mandatory in HTTP spec\n\tif (type==null || type.indexOf(\"text/html\")!==0)\n\t{\n\t\terror = new Error(errors.EXPECTED_HTML(type));\n\t\terror.code = response.statusCode;\n\t\treturn error;\n\t}\n}\n\n\n\n/*\n\tRequest a URL for its HTML contents and return a stream.\n*/\nfunction streamHtml(url, cache, options)\n{\n\tvar result;\n\t\n\t// Always gets the URL because response bodies are never cached\n\tvar request = bhttp.get(url,  // TODO :: https://github.com/joepie91/node-bhttp/issues/3\n\t{\n\t\tdiscardResponse: true,\n\t\theaders: { \"user-agent\":options.userAgent },\n\t\tstream: true\n\t})\n\t.then( function(orgResponse)\n\t{\n\t\tvar response = simpleResponse(orgResponse);\n\t\t\n\t\tresult = checkErrors(response);\n\t\t\n\t\tif (result === undefined)\n\t\t{\n\t\t\tresult = \n\t\t\t{\n\t\t\t\tresponse: response,\n\t\t\t\tstream: orgResponse\n\t\t\t};\n\t\t\t\n\t\t\t// Send response of redirected url to cache\n\t\t\tif (options.cacheResponses===true && response.url!==url)\n\t\t\t{\n\t\t\t\t// Will always overwrite previous value\n\t\t\t\tcache.set(response.url, response);  // TODO :: store `request` instead to be consistent?\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn response;\n\t})\n\t.catch( function(error)\n\t{\n\t\t// The error will be stored as a response\n\t\treturn error;\n\t});\n\t\n\t// Send response to cache -- it will be available to `cache.get()` before being resolved\n\tif (options.cacheResponses === true)\n\t{\n\t\t// Will always overwrite previous value\n\t\tcache.set(url, request);\n\t}\n\t\n\t// Send result to caller\n\treturn request.then( function(response)\n\t{\n\t\tif (response instanceof Error === true) throw response;\n\t\tif (result instanceof Error === true) throw result;\n\t\t\n\t\treturn result;\n\t});\n}\n\n\n\nmodule.exports = streamHtml;\n","/home/travis/build/npmtest/node-npmtest-broken-link-checker/node_modules/broken-link-checker/lib/public/SiteChecker.js":"\"use strict\";\nvar getRobotsTxt = require(\"../internal/getRobotsTxt\");\nvar matchUrl     = require(\"../internal/matchUrl\");\nvar parseOptions = require(\"../internal/parseOptions\");\nvar reasons      = require(\"../internal/messages\").reasons;\n\nvar HtmlUrlChecker = require(\"./HtmlUrlChecker\");\n\nvar maybeCallback = require(\"maybe-callback\");\nvar RequestQueue = require(\"limited-request-queue\");\nvar UrlCache = require(\"urlcache\");\n\n\n\nfunction SiteChecker(options, handlers)\n{\n\tvar thisObj = this;\n\t\n\treset(this);\n\t\n\tthis.handlers = handlers || {};\n\tthis.options = options = parseOptions(options);\n\t\n\tthis.sitePagesChecked = new UrlCache({ expiryTime: this.options.cacheExpiryTime });\n\t\n\tthis.siteUrlQueue = new RequestQueue(\n\t{\n\t\tmaxSockets: 1,\n\t\trateLimit: this.options.rateLimit\n\t},\n\t{\n\t\titem: function(input, done)\n\t\t{\n\t\t\tthisObj.currentCustomData = input.data.customData;\n\t\t\tthisObj.currentDone = done;\n\t\t\tthisObj.currentSiteUrl = input.url;  // TODO :: strip after hostname?\n\t\t\t\n\t\t\t// Support checking sites multiple times\n\t\t\tthisObj.sitePagesChecked.clear();\n\t\t\t\n\t\t\tif (options.honorRobotExclusions === true)\n\t\t\t{\n\t\t\t\tgetRobotsTxt(thisObj.currentSiteUrl, options).then( function(robots)\n\t\t\t\t{\n\t\t\t\t\tthisObj.currentRobotsTxt = robots;\n\t\t\t\t\t\n\t\t\t\t\tmaybeCallback(thisObj.handlers.robots)(robots, thisObj.currentCustomData);\n\t\t\t\t/*})\n\t\t\t\t.catch( function(error)\n\t\t\t\t{\n\t\t\t\t\tmaybeCallback(thisObj.handlers.robots)(error, null);\n\t\t\t\t})\n\t\t\t\t.then( function()\n\t\t\t\t{*/\n\t\t\t\t\tenqueuePage(thisObj, thisObj.currentSiteUrl, thisObj.currentCustomData);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tenqueuePage(thisObj, thisObj.currentSiteUrl, thisObj.currentCustomData);\n\t\t\t}\n\t\t},\n\t\tend: function()\n\t\t{\n\t\t\t// Reduce memory usage\n\t\t\tthisObj.sitePagesChecked.clear();\n\t\t\t\n\t\t\t// Clear references for garbage collection\n\t\t\treset(thisObj);\n\t\t\t\n\t\t\tmaybeCallback(thisObj.handlers.end)();\n\t\t}\n\t});\n\t\n\tthis.htmlUrlChecker = new HtmlUrlChecker(this.options,\n\t{\n\t\thtml: function(tree, robots, response, pageUrl, customData)\n\t\t{\n\t\t\t// If was redirected\n\t\t\tif (response.url !== pageUrl)\n\t\t\t{\n\t\t\t\tthisObj.sitePagesChecked.set(response.url, true);\n\t\t\t\t\n\t\t\t\tfor (var i=0; i<response.redirects.length; i++)\n\t\t\t\t{\n\t\t\t\t\t// Avoid rechecking any redirected pages\n\t\t\t\t\tthisObj.sitePagesChecked.set( response.redirects[i].url, true );\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tmaybeCallback(thisObj.handlers.html)(tree, robots, response, pageUrl, customData);\n\t\t},\n\t\t_filter: function(result)  // undocumented handler\n\t\t{\n\t\t\t// Additional filters for excluding links\n\t\t\treturn maybeCheckLink(thisObj, result);\n\t\t},\n\t\tjunk: function(result, customData)\n\t\t{\n\t\t\tmaybeCallback(thisObj.handlers.junk)(result, customData);\n\t\t\t\n\t\t\tmaybeEnqueuePage(thisObj, result, customData);\n\t\t},\n\t\tlink: function(result, customData)\n\t\t{\n\t\t\tmaybeCallback(thisObj.handlers.link)(result, customData);\n\t\t\t\n\t\t\tmaybeEnqueuePage(thisObj, result, customData);\n\t\t},\n\t\tpage: function(error, pageUrl, customData)\n\t\t{\n\t\t\tmaybeCallback(thisObj.handlers.page)(error, pageUrl, customData);\n\t\t\t\n\t\t\t// Only the first page should supply an error to \"site\" handler\n\t\t\tif (thisObj.sitePagesChecked.length() <= 1)\n\t\t\t{\n\t\t\t\tthisObj.currentPageError = error;\n\t\t\t}\n\t\t},\n\t\tend: function()\n\t\t{\n\t\t\tmaybeCallback(thisObj.handlers.site)(thisObj.currentPageError, thisObj.currentSiteUrl, thisObj.currentCustomData);\n\t\t\t\n\t\t\t// Auto-starts next site, if any\n\t\t\t// If not, fires \"end\"\n\t\t\tthisObj.currentDone();\n\t\t}\n\t});\n}\n\n\n\nSiteChecker.prototype.clearCache = function()\n{\n\t// Does not clear `sitePagesChecked` because it would mess up any current scans\n\treturn this.htmlUrlChecker.clearCache();\n};\n\n\n\nSiteChecker.prototype.dequeue = function(id)\n{\n\treturn this.siteUrlQueue.dequeue(id);\n};\n\n\n\nSiteChecker.prototype.enqueue = function(firstPageUrl, customData)\n{\n\treturn this.siteUrlQueue.enqueue(\n\t{\n\t\turl: firstPageUrl,\n\t\tdata: { customData:customData }\n\t});\n};\n\n\n\nSiteChecker.prototype.numActiveLinks = function()\n{\n\treturn this.htmlUrlChecker.numActiveLinks();\n};\n\n\n\nSiteChecker.prototype.numQueuedLinks = function()\n{\n\treturn this.htmlUrlChecker.numQueuedLinks();\n};\n\n\n\nSiteChecker.prototype.numPages = function()\n{\n\treturn this.htmlUrlChecker.numPages();\n};\n\n\n\nSiteChecker.prototype.numSites = function()\n{\n\treturn this.siteUrlQueue.length();\n};\n\n\n\nSiteChecker.prototype.pause = function()\n{\n\tthis.htmlUrlChecker.pause();\n\treturn this.siteUrlQueue.pause();\n};\n\n\n\nSiteChecker.prototype.resume = function()\n{\n\tthis.htmlUrlChecker.resume();\n\treturn this.siteUrlQueue.resume();\n};\n\n\n\n/*SiteChecker.prototype.__getCache = function()\n{\n\treturn this.htmlUrlChecker.__getCache();\n};*/\n\n\n\n//::: PRIVATE FUNCTIONS\n\n\n\nfunction enqueuePage(instance, url, customData)\n{\n\t// Avoid links to self within page\n\tinstance.sitePagesChecked.set(url, true);\n\t\n\tinstance.htmlUrlChecker.enqueue(url, customData);\n}\n\n\n\nfunction isAllowed(instance, link)\n{\n\tif (instance.options.honorRobotExclusions===true /*&& instance.currentRobotsTxt!=null*/)\n\t{\n\t\t// TODO :: remove condition when/if `linkObj.invalidate()` is used in `HtmlChecker`\n\t\tif (link.url.resolved !== null)\n\t\t{\n\t\t\treturn instance.currentRobotsTxt.isAllowed(instance.options.userAgent, link.url.parsed.pathname);\n\t\t}\n\t}\n\t\n\treturn true;\n}\n\n\n\nfunction maybeCheckLink(instance, link)\n{\n\tif (link.internal===true && isAllowed(instance, link)===false)\n\t{\n\t\treturn \"BLC_ROBOTS\";\n\t}\n}\n\n\n\nfunction maybeEnqueuePage(instance, link, customData)\n{\n\tvar attrSupported,i,redirects,tagGroup;\n\t\n\t// Skip specific links that were excluded from checks\n\tif (link.excluded === true)\n\t{\n\t\tswitch (link.excludedReason)\n\t\t{\n\t\t\tcase \"BLC_KEYWORD\":\n\t\t\tcase \"BLC_ROBOTS\":  // TODO :: catches rel=nofollow links but will also catch meta/header excluded links -- fine?\n\t\t\tcase \"BLC_SCHEME\":\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\ttagGroup = instance.options.tags.recursive[instance.options.filterLevel][link.html.tagName];\n\t\n\tif (tagGroup != null)\n\t{\n\t\tattrSupported = tagGroup[link.html.attrName];\n\t}\n\t\n\tif (\n\t   \t(attrSupported !== true) || \n\t   \t(link.broken === true) || \n\t   \t(link.internal !== true) || \n\t   \t(instance.sitePagesChecked.get(link.url.resolved) === true) || \n\t   \t(isAllowed(instance, link) === false)\n\t   )\n\t{\n\t\treturn false;\n\t}\n\t\n\tif (link.url.redirected!=null && instance.sitePagesChecked.get(link.url.redirected)===true)\n\t{\n\t\tredirects = link.http.response.redirects;\n\t\t\n\t\tfor (i=0; i<redirects.length; i++)\n\t\t{\n\t\t\t// Because the final redirected page has already been [recursively] checked,\n\t\t\t// all redirects are stored as pages that have been checked\n\t\t\tinstance.sitePagesChecked.set(redirects[i].url, true);\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tenqueuePage(instance, link.url.resolved, customData);\n\t\n\treturn true;\n}\n\n\n\nfunction reset(instance)\n{\n\tinstance.currentCustomData = null;\n\tinstance.currentDone = null;\n\tinstance.currentPageError = null;\n\tinstance.currentRobotsTxt = null;\n\tinstance.currentSiteUrl = null;\n}\n\n\n\nmodule.exports = SiteChecker;\n","/home/travis/build/npmtest/node-npmtest-broken-link-checker/node_modules/broken-link-checker/lib/internal/getRobotsTxt.js":"\"use strict\";\nvar guard = require(\"robots-txt-guard\");\nvar parse = require(\"robots-txt-parse\");\n\nvar bhttp = require(\"bhttp\");\nvar urllib = require(\"url\");\nvar urlobj = require(\"urlobj\");\n\n\n\nfunction getRobotsTxt(url, options)\n{\n\turl = urlobj.parse(url);\n\t\n\t// TODO :: this mutates the original (if was an object)\n\turl.hash = null;\n\turl.path = url.pathname = \"/robots.txt\";\n\turl.query = null;\n\turl.search = null;\n\t\n\treturn bhttp.get(urllib.format(url),  // TODO :: https://github.com/joepie91/node-bhttp/issues/3\n\t{\n\t\tdiscardResponse: true,\n\t\theaders: { \"user-agent\":options.userAgent },\n\t\tstream: true\n\t})\n\t.then(parse)\n\t.then(guard);\n}\n\n\n\nmodule.exports = getRobotsTxt;\n"}